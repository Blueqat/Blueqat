# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018, The Blueqat Developers
# This file is distributed under the same license as the Blueqat package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Blueqat \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-08-19 23:46+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/ising.rst:2
msgid "Ising/QUBO problem"
msgstr ""

#: ../../source/ising.rst:4
msgid "Blueqat \"wq\" module is a module for solbing Ising and Quadratic Unconstrained Binary Optimization (QUBO) problems. It includes local solver for Simulated Annealing (SA) and Simulated Quantum Annealing (SQA). You can also submit problems to D-Wave cloud machine using wq module."
msgstr ""

#: ../../source/ising.rst:9
msgid "What is Ising model"
msgstr ""

#: ../../source/ising.rst:11
msgid "Real Quantum Annealing (QA) machines are built upon physical model called Ising model, which can be computationally simulated on our laptops with algorithms called Simulated Annealing (SA) or Simulated Quantum Annealing (SQA). 1-dimensional Ising model is a 1D array of quantum bits (qubits), each of them has a ‘spin’ of +1 (up) or -1 (down). 2-dimensional Ising model is similar, it consists of a plainer lattice and has more adjacent qubits than 1D. Although the complex physics may be overwhelming to you, wq module let you easily calculate the model without knowing much about them."
msgstr ""

#: ../../source/ising.rst:19
msgid "Combinatorial Optimization problem and SA"
msgstr ""

#: ../../source/ising.rst:21
msgid "Simulated Annealing (SA) can be used to solve combinatorial optimization problems of some forms, and Ising model is one of them. Metropolis sampling based Monte-Carlo methods are used in such procedures."
msgstr ""

#: ../../source/ising.rst:26
msgid "Hamiltonian"
msgstr ""

#: ../../source/ising.rst:28
msgid "To solve Ising model with SA, we have to set Jij/hi which describes how strong a pair of qubits are coupled, and how strong a qubit is biased, respectively."
msgstr ""

#: ../../source/ising.rst:32
msgid "Simulated Annealing and Simulated Quantum Annealing"
msgstr ""

#: ../../source/ising.rst:34
msgid "We also have algorithm called Simulated Quantum Annealing(SQA) to solve Ising problems, in which quantum effects are taken into account. The effect of quantum superposition is approximated by the parallel execution of different world-line, by which we can effectively simulate wilder quantum nature. Technically, path-integral methods based on Suzuki-Trotter matrix decomposition are used in the algorithm."
msgstr ""

#: ../../source/ising.rst:41
msgid "Checking and Verifying solutions"
msgstr ""

#: ../../source/ising.rst:43
msgid "We can calculate how good (or bad) a solution is by calculating ‘Energy’ of the solution, which can be done by a wq module one-liner. Repeatedly solving Ising model, comparing that energy may let you know which is the best, or better answer to the problem. If the problem is of NP, then checking whether the constraints are fulfilled can also be calculated in polynomial time."
msgstr ""

#: ../../source/ising.rst:49
msgid "QUBO"
msgstr ""

#: ../../source/ising.rst:51
msgid "Ising model problems are represented by Quadratic Unconstrained Binary Optimization (QUBO) problems. Although variables in combinatorial optimization problems are of {0, 1}, quantum spins above are represented by {-1, 1}, so we have to transform their representation. wq module can automatically handle them, so you do not have to know about {-1, 1} things."
msgstr ""

#: ../../source/ising.rst:56
msgid "Learn more about QUBO"
msgstr ""

#: ../../source/ising.rst:58
msgid "Let's learn more about QUBO here."
msgstr ""

#: ../../source/ising.rst:60
msgid "Now there are three boxes labeled :math:`x_{0}, x_{1}, x_{2}` and we think the problem to choose some boxes from them."
msgstr ""

#: ../../source/ising.rst:62
msgid "First, we define the box's value = 1 when the box is chosen, and value = 0 otherwise. For example when you choose :math:`x_{0}`, box's values are :math:`x_{0} = 1, x_{1} = 0, x_{2} = 0`. This can be represented as computer friendly array format [1, 0, 0]."
msgstr ""

#: ../../source/ising.rst:66
msgid "Next, we define the problem we want to solve \"choose two from three boxes.\" We must think of a function E(x) for the problem, which takes minimum value when the problem is solved. We use the following function:"
msgstr ""

#: ../../source/ising.rst:70
msgid "E(x) = (x_{0} + x_{1} + x_{2} - 2) ^ 2"
msgstr ""

#: ../../source/ising.rst:73
msgid "Let's check the results:"
msgstr ""

#: ../../source/ising.rst:75
msgid "If you choose :math:`x_{0}` alone, :math:`E(x) = (1 + 0 + 0 - 2) ^ 2 = (-1) ^ 2 = 1`"
msgstr ""

#: ../../source/ising.rst:76
msgid "If you choose :math:`x_{0}` and :math:`x_{1}`, :math:`E(x) = (1 + 1 + 0 - 2) ^ 2 = (0) ^ 2 = 0`"
msgstr ""

#: ../../source/ising.rst:77
msgid "If you choose all, :math:`E(x) = (1 + 1 + 1 - 2) ^ 2 = (1) ^ 2 = 1`"
msgstr ""

#: ../../source/ising.rst:79
msgid "The minimum value of E(x) is 0 when you choose two of three, so you can confirm the E(x) above is the appropriate function for solving this problem. Let's expand this E(x) as the following:"
msgstr ""

#: ../../source/ising.rst:82
msgid "E(x) &= (x_{0} + x_{1} + x_{2} - 2) ^ 2 \\\\      &= (x_{0} + x_{1} + x_{2} - 2) (x_{0} + x_{1} + x_{2} - 2) \\\\      &= x_{0} ^ 2 + x_{1} ^ 2 + x_{2} ^ 2 + 2 x_{0} x_{1} + 2 x_{0} x_{2} + 2 x_{1} x_{2} - 4 x_{0} - 4 x_{1} - 4 x_{2} + 4"
msgstr ""

#: ../../source/ising.rst:88
msgid "Remember that :math:`x` takes 0 or 1. So we can use the equation :math:`x = x ^ 2 = x x`. Apply it to E(x)."
msgstr ""

#: ../../source/ising.rst:91
msgid "E(x) &= x_{0} ^ 2 + x_{1} ^ 2 + x_{2} ^ 2 + 2 x_{0} x_{1} + 2 x_{0} x_{2} + 2 x_{1} x_{2} - 4 x_{0} - 4 x_{1} - 4 x_{2} + 4 \\\\      &= x_{0} ^ 2 + x_{1} ^ 2 + x_{2} ^ 2 + 2 x_{0} x_{1} + 2 x_{0} x_{2} + 2 x_{1} x_{2} - 4 x_{0} x_{0} - 4 x_{1} x_{1} - 4 x_{2} x_{2} + 4 \\\\      &= -3 x_{0} x_{0} −3 x_{1} x_{1} -3 x_{2} x_{2} + 2 x_{0} x_{1} + 2 x_{0} x_{2} + 2 x_{1} x_{2} + 4"
msgstr ""

#: ../../source/ising.rst:97
msgid "Next, we want to convert function E(x) to a matrix which shapes like the following."
msgstr ""

#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
msgid ":math:`x_{0}`"
msgstr ""

#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
msgid ":math:`x_{1}`"
msgstr ""

#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
msgid ":math:`x_{2}`"
msgstr ""

#: ../../source/ising.rst:107
msgid "The first term of the last line of E(x) above multiplys :math:`x_{0}` and :math:`x_{0}`, then multiplys the product and -3. So put -3 in the intersection cell of :math:`x_{0}` and :math:`x_{0}` like this:"
msgstr ""

#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
msgid "-3"
msgstr ""

#: ../../source/ising.rst:118
msgid "For the second and third term, put -3 in the intersection cell of :math:`x_{1}` and :math:`x_{1}`, :math:`x_{2}` and :math:`x_{2}`."
msgstr ""

#: ../../source/ising.rst:128
msgid "The next term multiplys :math:`x_{0}` and :math:`x_{1}`, then multiplys the product and 2. So put 2 in the intersection cell of :math:`x_{0}` and :math:`x_{1}`."
msgstr ""

#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
#: ../../source/ising.rst:1
msgid "2"
msgstr ""

#: ../../source/ising.rst:139
msgid "For the next two terms, put 2 in the intersection cell of :math:`x_{0}` and :math:`x_{2}`, :math:`x_{1}` and :math:`x_{2}`. And we can ignore the last term 4, because it is not affect to find the minimum value of E(x) with the combination of :math:`x_{i}`."
msgstr ""

#: ../../source/ising.rst:142
msgid "As a result of the steps above, the matrix is finally the following shape. This is the QUBO to solve \"choose two from three boxes.\""
msgstr ""

#: ../../source/ising.rst:152
msgid "Use Simulated Annealing of wq module to solve this problem:"
msgstr ""

#: ../../source/ising.rst:162
msgid "Run the program and you will get the result [1, 1, 0]. This means :math:`x_{0}, x_{1}` are chosen. You will find the problem is solved correctly."
msgstr ""

#: ../../source/ising.rst:166
msgid "Steps to solve the QUBO problem is:"
msgstr ""

#: ../../source/ising.rst:168
msgid "Define E(x) that takes minimum value when the problem is solved."
msgstr ""

#: ../../source/ising.rst:170
msgid "Convert E(x) to QUBO matrix."
msgstr ""

#: ../../source/ising.rst:172
msgid "Supply the QUBO matrix to wq module and solve the problem with Simulated Annealing (SA)."
msgstr ""

#: ../../source/ising.rst:174
msgid "The most difficult step is 1., but you can find many useful examples in our :doc:`../tutorial`."
msgstr ""

#: ../../source/ising.rst:177
msgid "Define the row number of QUBO matrix as :math:`i` and the column number as :math:`j`, and each cell value as :math:`Q_{ij}`. So the E(x) can be represented as:"
msgstr ""

#: ../../source/ising.rst:180
msgid "E(x) = \\sum_{i} \\sum_{j} Q_{ij} x_{i} x_{j}"
msgstr ""

#: ../../source/ising.rst:184
msgid "Actually this :math:`Q_{ij}` is QUBO. You can find the last equation calculating E(x) above shapes this form."
msgstr ""

#: ../../source/ising.rst:186
msgid "See also `Wikipedia <https://en.wikipedia.org/wiki/Quadratic_unconstrained_binary_optimization>`_."
msgstr ""

